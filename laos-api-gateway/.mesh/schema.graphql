schema {
  query: Query
  mutation: Mutation
}

type Query {
  token(tokenId: String!, contractAddress: String!): TokenQueryResult
  tokens(orderBy: TokenOrderByOptions, pagination: TokenPaginationInput! = {first: 10}, where: TokenWhereInput): TokenConnection
  transfers(orderBy: TransferOrderByOptions, pagination: TransferPaginationInput, where: TransferWhereInput): [TransferQueryResult!]
  tokenHistory(pagination: TokenHistoryPaginationInput, tokenId: String!, contractAddress: String!): [TokenHistoryQueryResult!]
  status: String!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor: String
}

type TokenQueryResult {
  tokenId: String!
  owner: String!
  tokenUri: String
  tokenUriFetchState: String
  contractAddress: String
  createdAt: DateTime!
  initialOwner: String!
  name: String
  description: String
  image: String
  attributes: JSON
  block_number: Float!
}

"""
A date-time string in simplified extended ISO 8601 format (YYYY-MM-DDTHH:mm:ss.sssZ)
"""
scalar DateTime

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type TokenQueryResultSelect {
  tokenId: String!
  owner: String!
  tokenUri: String
  tokenUriFetchState: String
  contractAddress: String
  createdAt: DateTime!
  initialOwner: String!
  name: String
  description: String
  image: String
  attributes: JSON
  block_number: Float!
  logIndex: Float!
}

type TokenEdge {
  cursor: String!
  node: TokenQueryResult!
}

type TokenConnection {
  edges: [TokenEdge!]!
  pageInfo: PageInfo!
}

type TransferQueryResult {
  from: String!
  to: String!
  timestamp: DateTime!
  blockNumber: Float!
  txHash: String!
  tokenId: String!
  contractAddress: String
}

type TokenHistoryQueryResult {
  contractAddress: String
  tokenUri: String
  tokenUriFetchState: String
  name: String
  description: String
  image: String
  attributes: JSON
  block_number: Float!
  tx_hash: String!
  updatedAt: DateTime!
}

input PaginationInput {
  limit: Int!
  offset: Int! = 0
}

input TransferPaginationInput {
  limit: Int!
  offset: Int! = 0
}

input TokenPaginationInput {
  first: Int!
  after: String
}

input TokenHistoryPaginationInput {
  limit: Int!
  offset: Int! = 0
  orderBy: TokenHistoryOrderByOptions
}

"""Possible options for ordering token histories"""
enum TokenHistoryOrderByOptions {
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

input TransferWhereInput {
  tokenId: String
  contractAddress: String
  to: String
  from: String
}

input TokenWhereInput {
  contractAddress: String
  owner: String
}

"""Possible options for ordering tokens"""
enum TokenOrderByOptions {
  CREATED_AT_ASC
  CREATED_AT_DESC
}

"""Possible options for ordering transfers"""
enum TransferOrderByOptions {
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  BLOCKNUMBER_ASC
  BLOCKNUMBER_DESC
}

type Mutation {
  mint(input: MintInput!): MintResponse!
  evolve(input: EvolveInput!): EvolveResponse!
  broadcast(input: BroadcastInput!): BroadcastResponse!
}

type MintResponse {
  tokenId: String!
  success: Boolean!
}

input MintInput {
  laosContractAddress: String!
  mintTo: String!
  name: String!
  description: String
  attributes: String
  image: String
}

type EvolveResponse {
  tokenId: String!
  success: Boolean!
  tokenUri: String!
  tx: String!
}

input EvolveInput {
  laosContractAddress: String!
  tokenId: String!
  name: String!
  description: String
  attributes: String
  image: String
}

type BroadcastResponse {
  tokenId: String!
  success: Boolean!
}

input BroadcastInput {
  tokenId: String!
  chainId: String!
  ownershipContractAddress: String!
}